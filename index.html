<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Clash-like Single Battle Prototype</title>
  <style>
    html,body { margin:0; padding:0; height:100%; background:#222; color:#eee; font-family:Arial,Helvetica,sans-serif; }
    #game { width:100%; height:100vh; display:block; }
    .info { position: absolute; top:8px; left:8px; z-index:100; background:rgba(0,0,0,0.4); padding:6px 8px; border-radius:6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game"></div>
  <div class="info">Prototype: Drag a card to your side to spawn. CPU will play too. No art â€” rectangles only.</div>

<script>
/* === Configuration & Data Models === */
const CONFIG = {
  width: 940, height: 540,
  world: { cols: 20, rows: 12 }, // discretization for tile placements (not strictly required but helps)
  elixirRate: 1 / 2.8, // elixir per second base
  maxElixir: 10,
  doubleElixirStart: 60, // seconds (last minute double)
  matchTime: 180, // 3 minutes
  tileSize: 48,
  lanes: { leftBridgeX: 420, rightBridgeX: 520 }, // approximate bridge X positions
};

/* Cards: minimal set to demo behavior.
   Each card defines: id, cost, type ('troop'|'building'|'spell'),
   hp, dmg, atkSpeed, range, moveSpeed, targeting (buildingsOnly/airAllowed/groundOnly), splashRadius
*/
const CARD_DEFS = {
  'knight': { id:'knight', cost:3, type:'troop', hp: 120, dmg: 30, atkSpeed: 1.1, range:20, moveSpeed: 60, targets:'any', splash:0 },
  'archer': { id:'archer', cost:3, type:'troop', hp:70, dmg:20, atkSpeed:1.0, range:140, moveSpeed:40, targets:'any', splash:0, projectileSpeed:240 },
  'giant':  { id:'giant',  cost:5, type:'troop', hp:360, dmg:45, atkSpeed:1.3, range:18, moveSpeed:34, targets:'buildingsOnly', splash:0 },
  'skeletons':{ id:'skeletons', cost:1, type:'troop', hp:20, dmg:12, atkSpeed:1.4, range:10, moveSpeed:78, targets:'any', count:3, splash:0 },
  'cannon': { id:'cannon', cost:3, type:'building', hp:220, dmg:40, atkSpeed:1.0, range:140, splash:0 },
  'furnace':{ id:'furnace', cost:4, type:'building', hp:200, dmg:18, atkSpeed:3.5, spawnEvery:4.0 }, // spawns small unit periodically
  'fireball':{ id:'fireball', cost:4, type:'spell', dmg:120, radius:64 },
  'tombstone':{ id:'tombstone', cost:3, type:'building', hp:120, spawnOnDeath:4 } // spawns skeletons when killed
};

/* Utility helpers */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

/* Phaser game */
const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: CONFIG.width,
  height: CONFIG.height,
  backgroundColor: '#7aaaff',
  parent: 'game',
  scene: {
    preload, create, update
  }
});

function preload(){}
function create(){
  const scene = this;
  scene.startTime = scene.time.now / 1000;
  scene.matchClock = CONFIG.matchTime;
  scene.elixir = 4.0;
  scene.elixirRate = CONFIG.elixirRate;
  scene.player = { deck: createDeck(), hand: [], grave: [], towers: {} };
  scene.cpu = { deck: createDeck(true), hand: [], towers: {}, playCooldown:0 };

  // arena layout: top (cpu) and bottom (player)
  scene.arena = {
    riverY: CONFIG.height/2 - 20,
    topZoneY: 40,
    bottomZoneY: CONFIG.height - 100
  };

  // draw arena visuals: river and bridges
  drawArena(scene);

  // create towers: left/right princess & king for both players
  createTowers(scene);

  // UI: elixir bar and hand
  scene.elixirText = scene.add.text(10, CONFIG.height - 30, 'Elixir: 4.0', { font: '16px Arial', fill:'#fff', backgroundColor:'rgba(0,0,0,0.4)', padding:4 });
  scene.timeText = scene.add.text(CONFIG.width - 140, 10, '', { font: '18px Arial', fill:'#fff', backgroundColor:'rgba(0,0,0,0.4)', padding:6 });

  // card hand UI
  scene.cardGroup = scene.add.group();
  refillHand(scene.player, scene);
  refillHand(scene.cpu, scene);

  // input: dragging to place card
  setupCardInput(scene);

  // storage for entities
  scene.entities = scene.add.group();

  // physics: use simple timers & movement; manual updates in update()
  scene.eventsTimer = 0;

  // scripted CPU opponent (simple simulation)
  scene.cpuScript = { nextPlayAt: 1.5 };

  // text for winner
  scene.winnerText = scene.add.text(CONFIG.width/2, CONFIG.height/2, '', {font:'30px Arial', fill:'#fff' }).setOrigin(0.5).setDepth(100).setVisible(false);
}

function update(time, delta){
  const scene = this;
  const s = delta/1000;

  // update match clock
  scene.matchClock -= s;
  if(scene.matchClock <= 0){ scene.matchClock = 0; endMatch(scene, evaluateWinner(scene)); return; }
  scene.timeText.setText(`Time: ${Math.floor(scene.matchClock)}s`);

  // elixir regen, accelerate during last minute -> double elixir
  let currentRate = scene.elixirRate;
  if(scene.matchClock <= CONFIG.doubleElixirStart){ currentRate *= 2; }
  scene.elixir = clamp(scene.elixir + currentRate*s, 0, CONFIG.maxElixir);
  scene.elixirText.setText('Elixir: ' + scene.elixir.toFixed(1));

  // CPU simple behavior: if cooldown elapsed, attempt to play a card from deck heuristically
  scene.cpu.playCooldown -= s;
  if(scene.cpu.playCooldown <= 0){
    cpuAttemptPlay(scene);
    scene.cpu.playCooldown = 0.6 + Math.random()*1.4; // a little randomness to simulate thinking
  }

  // update entities: troops movement, attacks, buildings spawn, projectiles
  updateEntities(scene, s);
}

/* ========== Deck & Hand ========== */
function createDeck(isCpu=false){
  // simple 8-card deck comprised of some defined cards
  const keys = Object.keys(CARD_DEFS);
  // deterministic but shuffled
  let deck = [];
  while(deck.length < 8){
    const k = keys[Math.floor(Math.random() * keys.length)];
    deck.push(CARD_DEFS[k]);
  }
  // ensure at least one win condition (giant or mortar)
  if(!deck.find(c=>c.id==='giant') && Math.random() < 0.5) deck[0]=CARD_DEFS.giant;
  return deck;
}

function refillHand(player, scene){
  // draw up to 4 cards visible
  player.hand.length = 0;
  for(let i=0;i<4;i++){
    player.hand.push(player.deck[i % player.deck.length]); // simple linear draw
  }
  renderHand(scene);
}

function renderHand(scene){
  // clear
  scene.cardGroup.clear(true,true);
  // draw player hand at bottom
  const pad = 12;
  const startX = (CONFIG.width - (scene.player.hand.length * (CONFIG.tileSize + pad))) / 2;
  scene.player.hand.forEach((card, idx)=>{
    const x = startX + idx * (CONFIG.tileSize + pad);
    const y = CONFIG.height - CONFIG.tileSize - 8;
    const rect = scene.add.rectangle(x, y, CONFIG.tileSize, CONFIG.tileSize, 0xdddddd).setOrigin(0,0);
    const bg = scene.add.rectangle(x+4, y+4, CONFIG.tileSize-8, CONFIG.tileSize-8, 0x333333).setOrigin(0,0);
    const txt = scene.add.text(x+6, y+8, card.id + '\n' + card.cost, { font:'11px Arial', fill:'#fff' }).setOrigin(0,0);
    const container = scene.add.container(x,y,[rect,bg,txt]);
    container.setSize(CONFIG.tileSize, CONFIG.tileSize);
    container.cardDef = card;
    container.setInteractive(new Phaser.Geom.Rectangle(0,0,CONFIG.tileSize,CONFIG.tileSize), Phaser.Geom.Rectangle.Contains);
    // cost marker
    const costText = scene.add.text(x+CONFIG.tileSize-18, y+CONFIG.tileSize-18, card.cost, {font:'12px Arial', fill:'#fff', backgroundColor:'rgba(0,0,0,0.6)', padding:2}).setOrigin(0.5);
    scene.cardGroup.addMultiple([container,costText]);
    // attach drag
    scene.input.setDraggable(container);
  });
}

/* Input handling: drag cards, on drop spawn card if legal and enough elixir */
function setupCardInput(scene){
  scene.input.on('dragstart', (pointer, gameObject)=> {
    gameObject.setScale(1.05);
  });
  scene.input.on('drag', (pointer, gameObject, dragX, dragY)=>{
    gameObject.x = dragX; gameObject.y = dragY;
  });
  scene.input.on('dragend', (pointer, gameObject)=> {
    gameObject.setScale(1);
    const card = gameObject.cardDef;
    const sceneY = gameObject.y;
    // only allow drop on player's half (lower half) and not over river
    if(sceneY > CONFIG.height/2 + 10 && scene.elixir >= card.cost){
      // compute tile-aligned location
      const spawnX = Phaser.Math.Clamp(Math.round(gameObject.x / CONFIG.tileSize) * CONFIG.tileSize + CONFIG.tileSize/2, 40, CONFIG.width - 40);
      const spawnY = Phaser.Math.Clamp(Math.round(gameObject.y / CONFIG.tileSize) * CONFIG.tileSize + CONFIG.tileSize/2, CONFIG.height/2 + 30, CONFIG.height - 120);
      playCard(scene, card, spawnX, spawnY, 'player');
      scene.elixir -= card.cost;
      // rotate deck: remove first, push to end (simple cycle)
      scene.player.deck.push(scene.player.deck.shift());
      refillHand(scene.player, scene);
    } else {
      // animate snapback
      refillHand(scene.player, scene);
    }
  });
}

/* ========== Spawning and Entities ========== */
let entityIdCounter = 1;

function playCard(scene, card, x, y, owner){
  // spawn concept: depending on card.type
  if(card.type === 'troop'){
    spawnTroop(scene, card, x, y, owner);
  } else if(card.type === 'building'){
    spawnBuilding(scene, card, x, y, owner);
  } else if(card.type === 'spell'){
    castSpell(scene, card, x, y, owner);
  }
}

/* entity base creation helper */
function createEntity(scene, type, data){
  const id = 'e' + (entityIdCounter++);
  const sprite = scene.add.rectangle(data.x, data.y, data.width || 28, data.height || 28, data.color || 0xffffff).setDepth(10);
  const hpText = scene.add.text(data.x-14, data.y-26, Math.round(data.hp), {font:'12px Arial', fill:'#000'}).setDepth(11);
  const container = scene.add.container(0,0,[sprite,hpText]);
  container.x = data.x; container.y = data.y;
  container.sprite = sprite; container.hpText = hpText;
  container.id = id;
  container.type = type;
  container.owner = data.owner;
  container.hp = data.hp;
  container.maxHp = data.maxHp || data.hp;
  container.dmg = data.dmg || 0;
  container.atkSpeed = data.atkSpeed || 1;
  container.range = data.range || 10;
  container.moveSpeed = data.moveSpeed || 0;
  container.targets = data.targets || 'any';
  container.splash = data.splash || 0;
  container.attackCooldown = 0;
  container.alive = true;
  container.width = data.width || 28;
  container.height = data.height || 28;
  container.behaviors = data.behaviors || {};
  scene.entities.add(container);
  return container;
}

function spawnTroop(scene, def, x, y, owner){
  // simple grouping for spawn-count (skeletons)
  if(def.count && def.count > 1){
    const offset = 18;
    for(let i=0;i<def.count;i++){
      const rx = x + (i - Math.floor(def.count/2)) * offset;
      spawnSingleTroop(scene, def, rx, y, owner);
    }
  } else {
    spawnSingleTroop(scene, def, x, y, owner);
  }
}
function spawnSingleTroop(scene, def, x, y, owner){
  const color = owner === 'player' ? 0x88ee88 : 0xee8888;
  const ent = createEntity(scene, 'troop', {
    x,y, owner, color,
    hp: def.hp, maxHp:def.hp, dmg:def.dmg, atkSpeed:def.atkSpeed, range:def.range, moveSpeed:def.moveSpeed, targets:def.targets, splash:def.splash, width:28,height:28
  });
  ent.cardId = def.id;
  ent.isAir = def.isAir || false;
  ent.target = null;
  ent.lastSeen = scene.time.now/1000;
}

function spawnBuilding(scene, def, x, y, owner){
  const color = owner === 'player' ? 0x6666ff : 0xff66ff;
  const ent = createEntity(scene, 'building', { x,y, owner, color, hp:def.hp, maxHp:def.hp, dmg:def.dmg, atkSpeed:def.atkSpeed, range:def.range, width:48, height:48 });
  ent.cardId = def.id;
  // special behaviors
  if(def.spawnEvery){
    ent.behaviors.spawnEvery = def.spawnEvery;
    ent.behaviors.spawnTimer = def.spawnEvery;
  }
  if(def.spawnOnDeath){
    ent.behaviors.spawnOnDeath = def.spawnOnDeath;
  }
}

function castSpell(scene, def, x, y, owner){
  // visual indicator
  const circ = scene.add.circle(x,y, def.radius || 32, owner==='player'?0xffaa33:0xff3333, 0.33).setDepth(50);
  scene.time.delayedCall(180, ()=>{ circ.destroy(); applySpellDamage(scene, def, x, y, owner); }, [], scene);
}

function applySpellDamage(scene, def, x, y, owner){
  scene.entities.getChildren().forEach(ent=>{
    if(!ent.alive) return;
    const d = Math.hypot(ent.x - x, ent.y - y);
    if(d <= (def.radius || 32) + (ent.width||28)/2){
      ent.hp -= def.dmg;
      if(ent.hp <= 0) killEntity(scene, ent);
    }
  });
}

/* ========== Towers ========== */
function createTowers(scene){
  // three towers per side; simple positions
  const leftX = CONFIG.width*0.20, rightX = CONFIG.width*0.80, kingX = CONFIG.width/2;
  const topY = 80, bottomY = CONFIG.height-80;
  scene.player.towers.left = createTower(scene, leftX, bottomY, 'player', 'princess');
  scene.player.towers.right = createTower(scene, rightX, bottomY, 'player', 'princess');
  scene.player.towers.king = createTower(scene, kingX, bottomY-18, 'player', 'king');
  scene.cpu.towers.left = createTower(scene, leftX, topY, 'cpu', 'princess');
  scene.cpu.towers.right = createTower(scene, rightX, topY, 'cpu', 'princess');
  scene.cpu.towers.king = createTower(scene, kingX, topY+18, 'cpu', 'king');
}

function createTower(scene, x, y, owner, type){
  const color = owner === 'player' ? 0x2233aa : 0xaa2222;
  const hp = (type==='king') ? 1200 : 600;
  const tower = createEntity(scene, 'tower', { x,y, owner, color, hp:hp, maxHp:hp, dmg:40, atkSpeed:1.2, range:160, width:68, height:68 });
  tower.isTower = true;
  tower.towerType = type;
  tower.lastShot = 0;
  tower.canTargetAir = true;
  tower.canTargetGround = true;
  // separate display label
  const label = scene.add.text(x-26, y-46, owner + '\n' + type + '\n' + tower.hp, {font:'12px Arial', fill:'#fff'}).setDepth(11);
  tower.hpText.destroy(); tower.hpText = label;
  return tower;
}

/* ========== Entity Updates: movement, targeting, attacks, death spawn, buildings spawn ========= */
function updateEntities(scene, dt){
  // iterate copy to allow kill during loop
  const ents = scene.entities.getChildren().slice();
  for(const ent of ents){
    if(!ent.alive) continue;

    // buildings: periodic spawn
    if(ent.type === 'building' && ent.behaviors.spawnEvery){
      ent.behaviors.spawnTimer -= dt;
      if(ent.behaviors.spawnTimer <= 0){
        // spawn a simple small troop near building
        const spawnX = ent.x + (ent.owner==='player' ? 0 : 0);
        const spawnY = ent.y + (ent.owner==='player' ? -40 : 40);
        spawnSingleTroop(scene, CARD_DEFS.skeletons, spawnX, spawnY, ent.owner);
        ent.behaviors.spawnTimer = ent.behaviors.spawnEvery;
      }
    }

    // towers: auto-scan for targets and shoot
    if(ent.isTower){
      ent.lastShot -= dt;
      const enemy = chooseTargetForEnt(scene, ent);
      if(enemy && ent.lastShot <= 0){
        ent.lastShot = ent.atkSpeed;
        shootProjectile(scene, ent, enemy);
      }
      continue;
    }

    // troops: if have target validate and attack, else move towards nearest tower (simple pathing: straight along lane)
    if(ent.type === 'troop'){
      // find/validate target
      if(!ent.target || !ent.target.alive || !isValidTarget(ent, ent.target)){
        ent.target = chooseTargetForEnt(scene, ent);
      }
      if(ent.target){
        const d = dist(ent, ent.target);
        if(d <= ent.range + (ent.target.width||28)/2){
          // attack
          ent.attackCooldown -= dt;
          if(ent.attackCooldown <= 0){
            ent.attackCooldown = ent.atkSpeed;
            // apply damage (projectile or instant)
            if(ent.cardId === 'archer' && ent.targets!=='buildingsOnly'){
              // spawn a projectile toward target with travel time
              shootProjectile(scene, ent, ent.target, {speed: (CARD_DEFS.archer.projectileSpeed||220)});
            } else {
              ent.target.hp -= ent.dmg;
              if(ent.target.hp <= 0) killEntity(scene, ent.target);
            }
          }
        } else {
          // move toward target
          const dx = ent.target.x - ent.x;
          const dy = ent.target.y - ent.y;
          const ang = Math.atan2(dy,dx);
          ent.x += Math.cos(ang) * ent.moveSpeed * dt;
          ent.y += Math.sin(ang) * ent.moveSpeed * dt;
          ent.sprite.x = ent.x; ent.sprite.y = ent.y; ent.hpText.x = ent.x - 14; ent.hpText.y = ent.y - 26;
          ent.container && (ent.container.x = ent.x, ent.container.y = ent.y);
        }
      } else {
        // no target: move forward toward enemy side (straight line)
        const goalY = ent.owner === 'player' ? 60 : CONFIG.height - 60;
        const dy = goalY - ent.y;
        const ang = Math.sign(dy);
        ent.y += ent.moveSpeed * dt * (ang>0?1:-1);
        ent.sprite.x = ent.x; ent.sprite.y = ent.y; ent.hpText.x = ent.x - 14; ent.hpText.y = ent.y - 26;
      }
    }

    // update HP text for all
    if(ent.hpText) {
      if(ent.isTower) ent.hpText.setText(`${ent.owner}\n${ent.towerType}\n${Math.round(ent.hp)}`);
      else ent.hpText.setText(`${Math.round(ent.hp)}`);
      ent.sprite.x = ent.x; ent.sprite.y = ent.y; ent.hpText.x = ent.x - 14; ent.hpText.y = ent.y - 26;
    }
  }
}

/* Target selection & validity: follows explicit targeting rules and retargeting logic */
function chooseTargetForEnt(scene, ent){
  // priority: nearest valid enemy unit within detection range, otherwise nearest enemy building (towers/buildings)
  const enemies = scene.entities.getChildren().filter(e => e.owner !== ent.owner && e.alive);
  let best = null; let bestDist = 99999;
  for(const e of enemies){
    if(!isValidTarget(ent,e)) continue;
    const d = dist(ent,e);
    if(d < bestDist){
      bestDist = d; best = e;
    }
  }
  return best;
}
function isValidTarget(ent, candidate){
  if(!candidate || !candidate.alive) return false;
  if(ent.targets === 'buildingsOnly'){
    return (candidate.type === 'building' || candidate.isTower);
  }
  // check flight/ground differences (not fully implemented in this minimal prototype)
  return true;
}

/* Projectiles */
function shootProjectile(scene, source, target, opts={}){
  const speed = opts.speed || 320;
  const proj = scene.add.circle(source.x, source.y, 6, 0xffff00).setDepth(40);
  const spawn = { x: source.x, y: source.y, targetId: target.id, sourceId: source.id };
  const lifetime = 6.0;
  const start = scene.time.now/1000;
  // simple projectile update using a closure timer
  scene.tweens.addCounter({
    from: 0, to: 1, duration: (dist(source,target)/speed)*1000, onUpdate: (tween)=>{
      const t = tween.getValue();
      proj.x = Phaser.Math.Linear(source.x, target.x, t);
      proj.y = Phaser.Math.Linear(source.y, target.y, t);
    }, onComplete: ()=>{
      // on impact: apply damage if target alive and within radius
      if(target.alive){
        target.hp -= source.dmg;
        if(target.hp <= 0) killEntity(scene, target);
      }
      proj.destroy();
    }
  });
}

/* Kill & death spawn */
function killEntity(scene, ent){
  if(!ent.alive) return;
  ent.alive = false;
  // death animation (flash)
  ent.sprite.fillColor = 0x444444;
  // spawn on death behavior for tombstone
  if(ent.type === 'building' && ent.behaviors.spawnOnDeath){
    for(let i=0;i<ent.behaviors.spawnOnDeath;i++){
      const rx = ent.x + (i - Math.floor(ent.behaviors.spawnOnDeath/2)) * 12;
      spawnSingleTroop(scene, CARD_DEFS.skeletons, rx, ent.y, ent.owner);
    }
  }
  // remove graphic after short delay
  scene.time.delayedCall(200, ()=>{ ent.sprite.destroy(); ent.hpText.destroy(); scene.entities.remove(ent,true); }, [], scene);
}

/* CPU AI: simple heuristic to play a card on its side */
function cpuAttemptPlay(scene){
  // choose a random playable card from CPU deck that fits elixir
  const playable = scene.cpu.deck.filter(c=>c.cost <= scene.elixir);
  if(playable.length === 0) return;
  // heuristic: if player has large troop near CPU tower, play defensive; else try to spawn a win condition toward player's side
  // simplest: pick randomly
  const card = playable[Math.floor(Math.random()*playable.length)];
  // compute spawn area on CPU side
  const spawnX = Phaser.Math.Clamp(Math.random() * (CONFIG.width - 160) + 80, 80, CONFIG.width-80);
  const spawnY = 80 + 40;
  playCard(scene, card, spawnX, spawnY, 'cpu');
  scene.elixir -= card.cost;
  // cycle CPU deck
  scene.cpu.deck.push(scene.cpu.deck.shift());
}

/* End match & evaluate winner: compare towers destroyed or king death */
function evaluateWinner(scene){
  // check if any king tower dead
  const playerKingAlive = scene.player.towers.king && scene.player.towers.king.alive;
  const cpuKingAlive = scene.cpu.towers.king && scene.cpu.towers.king.alive;
  if(!playerKingAlive && cpuKingAlive) return 'cpu';
  if(!cpuKingAlive && playerKingAlive) return 'player';
  // otherwise compare number of princess towers alive
  const pAlive = (scene.player.towers.left.alive?1:0) + (scene.player.towers.right.alive?1:0);
  const cAlive = (scene.cpu.towers.left.alive?1:0) + (scene.cpu.towers.right.alive?1:0);
  if(pAlive > cAlive) return 'player';
  if(cAlive > pAlive) return 'cpu';
  return 'draw';
}
function endMatch(scene, winner){
  scene.winnerText.setText(winner === 'draw' ? 'Draw' : (winner+' wins!')).setVisible(true);
  scene.scene.pause();
}

/* draw arena helper */
function drawArena(scene){
  const g = scene.add.graphics();
  // ground color halves
  g.fillStyle(0x558855,1); g.fillRect(0, CONFIG.height/2+10, CONFIG.width, CONFIG.height/2-10);
  g.fillStyle(0x335588,1); g.fillRect(0,0, CONFIG.width, CONFIG.height/2-10);
  // river
  g.fillStyle(0x3aa5ff,1); g.fillRect(0, CONFIG.height/2-30, CONFIG.width, 60);
  // bridges
  const bw = 80; const by = CONFIG.height/2 - 14;
  g.fillStyle(0x8c6a3d,1); g.fillRect(CONFIG.width/2 - bw - 60, by, 60, 28);
  g.fillRect(CONFIG.width/2 + 60, by, 60, 28);
  // lane separators (visual)
  g.lineStyle(2, 0x222222, 0.6); g.strokeRect(16, 16, CONFIG.width-32, CONFIG.height-32);
}

/* ========== End of prototype ========== */
</script>
</body>
</html>
